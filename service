#!/usr/bin/env python
import json
import re
import time
import traceback
from datetime import datetime, timedelta
from hashlib import md5
from itertools import islice
from sys import stderr
from time import sleep
from time import time as timestamp

from pytz import timezone, utc
from requests import get

from helper import Helper
from hosted import CONFIG, DEVICE, NODE
from mapping import API_MAPPING, CATEGORY_MAPPING, COLOUR_MAPPING

CONFIG.restart_on_update()

TIMEZONE = "Europe/Berlin"
REMOVE = re.escape(CONFIG["remove_string"].strip())


def log(something):
    if not isinstance(something, str):
        something = repr(something)
    stderr.write("[HAFAS service] {}\n".format(something))


def _now():
    tz = timezone(TIMEZONE)
    now = datetime.utcnow()
    now = now.replace(tzinfo=utc)
    now = now.astimezone(tz)
    now = now.replace(tzinfo=None)
    return now


def idle(seconds):
    log("idling for {} seconds".format(seconds))
    timeout = timestamp() + seconds
    while timestamp() < timeout:
        NODE["/time"](Helper.to_unixtimestamp(_now()))
        sleep(1)


class HAFASDeparture:
    def __init__(self, departure):
        self.json = departure
        self.duplicate = False
        self.follow = None

        for product in departure["Product"]:
            if product.get("name") and product.get("catCode"):
                self.symbol = product["name"]
                self.category = product["catCode"]
                self.operator = product.get("operatorCode", None)
                self.icon = product.get("icon", None)
                break
        else:
            self.symbol = ""
            self.category = -1
            self.operator = None
            self.icon = None

        if CONFIG["api_provider"] in CATEGORY_MAPPING:
            self.category_icon = CATEGORY_MAPPING[CONFIG["api_provider"]].get(
                str(self.category), ""
            )
        else:
            self.category_icon = ""

        scheduled = datetime.strptime(
            departure["date"] + " " + departure["time"], "%Y-%m-%d %H:%M:%S"
        )
        if "rtTime" in departure and "rtDate" in departure:
            self.departure = datetime.strptime(
                departure["rtDate"] + " " + departure["rtTime"], "%Y-%m-%d %H:%M:%S"
            )
            diff = self.departure - scheduled
            self.delay = int(diff.total_seconds() / 60)
        else:
            self.departure = scheduled
            self.delay = 0

    def __lt__(self, other):
        assert isinstance(other, HAFASDeparture)
        return self.departure < other.departure

    def _clean(self, key):
        return re.sub(
            "^(" + REMOVE + "[- ])",
            "",
            re.sub(
                "(\(" + REMOVE + "\))$",
                "",
                self.json[key].strip(),
                flags=re.IGNORECASE
            ),
            flags=re.IGNORECASE,
        ).strip()

    @property
    def destination(self):
        return self._clean("direction")

    @property
    def ignore_departure(self):
        if CONFIG["ignore_destination"] and re.match(
            CONFIG["ignore_destination"], direction
        ):
            return True
        return False

    @property
    def line_colour(self):
        font_r, font_g, font_b = (1, 1, 1)
        if not CONFIG["coloured_lines"]:
            r, g, b = (0.3, 0.3, 0.3)
        else:
            provider = CONFIG["api_provider"]
            if (
                provider in COLOUR_MAPPING
                and self.operator in COLOUR_MAPPING[provider]
                and self.symbol in COLOUR_MAPPING[provider][self.operator]
            ):
                r, g, b = COLOUR_MAPPING[provider][self.operator][self.symbol]
            elif self.icon is not None:
                r, g, b = Helper.hex2rgb(self.icon["backgroundColor"]["hex"][1:])
                font_r, font_g, font_b = Helper.hex2rgb(
                    self.icon["foregroundColor"]["hex"][1:]
                )
            else:
                name_hash = md5(self.json["name"]).hexdigest()
                r, g, b = Helper.hex2rgb(name_hash[:6])
                h, s, v = Helper.rgb2hsv(r * 255, g * 255, b * 255)
                if v > 0.75:
                    font_r, font_g, font_b = (0, 0, 0)
        return {
            "background_colour": {
                "r": r,
                "g": g,
                "b": b,
            },
            "font_colour": {
                "r": font_r,
                "g": font_g,
                "b": font_b,
            },
        }

    @property
    def stop(self):
        return self._clean("stop")

    @property
    def platform(self):
        if "platform" in self.json:
            return "{} {}".format(self.json["platform"].get("type", ""), self.json["platform"].get("text", "")).strip()
        if "track" in self.json:
            return self.json["track"]
        return ""


class HAFASFetcher:
    def __init__(self):
        self.departures = []

    def fetch_and_parse(self, stop_id):
        stop_info = self._fetch(stop_id)
        departures = []
        for dep in stop_info["Departure"]:
            departures.append(HAFASDeparture(dep))
        departures = sorted(departures)
        for n, dep in enumerate(departures):
            for follow in islice(departures, n + 1, None):
                if dep.symbol == follow.symbol and (
                    (dep.platform != "" and dep.platform == follow.platform)
                    or (dep.platform == "" and dep.destination == follow.destination)
                ):
                    dep.follow = follow
                    break
        self.departures.extend(departures)

    def _fetch(self, stop_id):
        key = CONFIG["api_key"].strip()

        if key.startswith("http://") or key.startswith("https://"):
            key = key.rstrip("/")
            url = "{prefix}/{stop}.json".format(
                prefix=key,
                stop=stop_id,
            )
        else:
            url = API_MAPPING[CONFIG["api_provider"]].format(
                stop=stop_id,
                minutes=CONFIG["request_hours"] * 60,
                key=key,
            )
        log(
            "Requesting {stop} info from {url}".format(
                stop=stop_id,
                url=url,
            )
        )
        r = get(url)
        r.raise_for_status()
        return r.json()

    def sort_and_deduplicate(self):
        departures = sorted(self.departures)
        for n, dep in enumerate(departures):
            for follow in islice(departures, n + 1, None):
                if (
                    dep.destination == follow.destination
                    and dep.symbol == follow.symbol
                    and (
                        (
                            dep.stop != follow.stop
                            and abs(
                                Helper.to_unixtimestamp(dep.departure)
                                - Helper.to_unixtimestamp(follow.departure)
                            )
                            < 120
                        )
                        or (
                            dep.stop == follow.stop
                            and abs(
                                Helper.to_unixtimestamp(dep.departure)
                                - Helper.to_unixtimestamp(follow.departure)
                            )
                            < 10
                        )
                    )
                ):
                    dep.duplicate = True
                    break
        self.departures = [dep for dep in departures if not dep.duplicate]

    def write_json(self):
        log("writing {} departures to json".format(len(self.departures)))
        out = []
        for dep in self.departures:
            departure = {
                "category": dep.category,
                "direction": dep.destination,
                "icon": dep.category_icon,
                "operator": dep.operator,
                "platform": dep.platform,
                "stop": dep.stop,
                "symbol": dep.symbol,
                "time": dep.departure.strftime("%H:%M"),
                "timestamp": Helper.to_unixtimestamp(dep.departure),
                "next_timestamp": Helper.to_unixtimestamp(dep.follow.departure)
                if dep.follow
                else 0,
                "next_time": dep.follow.departure.strftime("%H:%M")
                if dep.follow
                else "",
            }
            departure.update(dep.line_colour)
            out.append(departure)
        with file("departures.json", "wb") as f:
            f.write(json.dumps(out, ensure_ascii=False).encode("utf8"))


def main():
    idle(2)

    while True:
        try:
            stops = CONFIG["stop_ids"].split(",")
            hafas = HAFASFetcher()
            for stop in stops:
                hafas.fetch_and_parse(stop)
            hafas.sort_and_deduplicate()
            hafas.write_json()

            if CONFIG["api_key"].startswith("http://") or CONFIG["api_key"].startswith(
                "https://"
            ):
                idle(15)
            else:
                sleep_time = max(
                    86400 / (CONFIG["requests_max_per_day"] / len(stops)),
                    30,
                )

                idle(sleep_time)
        except Exception:
            traceback.print_exc()
            time.sleep(30)


if __name__ == "__main__":
    main()
